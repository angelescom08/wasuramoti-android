package karuta.hpnpwd.wasuramoti

import _root_.android.app.{AlertDialog,AlarmManager,NotificationManager}
import _root_.android.content.{DialogInterface,Context,Intent,SharedPreferences}
import _root_.android.database.sqlite.SQLiteDatabase
import _root_.android.preference.PreferenceManager
import _root_.android.text.{TextUtils,Html}
import _root_.android.util.Base64
import _root_.android.os.Handler
import _root_.android.media.AudioManager
import _root_.android.view.{LayoutInflater,View}
import _root_.android.widget.{TextView,Button}

import _root_.java.io.{File,ByteArrayOutputStream,ObjectOutputStream,ByteArrayInputStream,ObjectInputStream,InvalidClassException}
import _root_.java.text.SimpleDateFormat
import _root_.java.util.Date

import scala.collection.mutable

object Globals {
  val IS_DEBUG = false
  val TABLE_FUDASETS = "fudasets"
  val TABLE_FUDALIST = "fudalist"
  val TABLE_READFILTER = "readfilter"
  val TABLE_READERS = "readers"
  val DATABASE_NAME = "wasuramoti.db"
  val DATABASE_VERSION = 2
  val READER_DIR = "wasuramoti_reader"
  val ASSETS_READER_DIR="reader"
  val CACHE_SUFFIX_OGG = "_copied.ogg"
  val CACHE_SUFFIX_WAV = "_decoded.wav"
  val HEAD_SILENCE_LENGTH = 200 // in milliseconds
  val global_lock = new Object()
  val notify_timers = new mutable.HashMap[Int,Intent]()
  var database = None:Option[DictionaryOpenHelper]
  var prefs = None:Option[SharedPreferences]
  var player = None:Option[KarutaPlayer]
  var setButtonText = None:Option[Either[String,Int]=>Unit]
  var alarm_manager = None:Option[AlarmManager]
  var notify_manager = None:Option[NotificationManager]
  var is_playing = false
  var forceRefresh = false
  var audio_volume_bkup = None:Option[Int]
}

// this serialVersionUID is generated by
// $ serialver -classpath target/scala-2.9.2/classes/:/usr/share/scala/lib/scala-library.jar karuta.hpnpwd.wasuramoti.EqualizerSeq
@SerialVersionUID(-1688597103216929372L)
class EqualizerSeq(var seq:Seq[Option[Double]] = Seq()) extends Serializable{
}

object Utils {
  // Since every Activity has a possibility to be killed by android when it is background,
  // all the Activity in this application should call this method in onCreate()
  def initGlobals(app_context:Context) {
    Globals.global_lock.synchronized{
      if(Globals.database.isEmpty){
        Globals.database = Some(new DictionaryOpenHelper(app_context))
      }
      PreferenceManager.setDefaultValues(app_context,R.xml.conf,false)
      if(Globals.prefs.isEmpty){
        Globals.prefs = Some(PreferenceManager.getDefaultSharedPreferences(app_context))
      }
      ReaderList.setDefaultReader(app_context)
    }
  }

  def makeTimerText(context:Context):String = {
     val nt = Globals.notify_timers
     var title = context.getResources.getString(R.string.timers_remaining)
     nt.toList.sortWith{case ((k1,v1),(k2,v2)) => v1.getExtras.getLong("limit_millis") < v1.getExtras.getLong("limit_millis")}.map{case (k,v) =>
       val millis = v.getExtras.getLong("limit_millis")
       val minutes_left = scala.math.ceil((millis - System.currentTimeMillis()) / (1000 * 60.0)).toInt
       val df = new SimpleDateFormat(
         if( minutes_left < 60 * 24){
           "HH:mm"
         }else{
           "MM/dd HH:mm"
         }
       )
       df.format(new Date(millis)) + " (" + minutes_left.toString + " " + context.getResources.getString(R.string.timers_minutes_left) + ")"
     }.foldLeft(title)(_+"\n"+_)
  }
  def withTransaction(db:SQLiteDatabase,func:()=>Unit){
    db.beginTransaction()
    func()
    db.setTransactionSuccessful()
    db.endTransaction
  }
  def confirmDialog(context:Context,arg:Either[String,Int],func_yes:Unit=>Unit,func_no:Unit=>Unit=identity[Unit]){
    val builder = new AlertDialog.Builder(context)
    val str = arg match {
      case Left(x) => x
      case Right(x) => context.getResources().getString(x)
    }
    builder.setMessage(str).setPositiveButton("YES",new DialogInterface.OnClickListener(){
        override def onClick(interface:DialogInterface,which:Int){
          func_yes()
        }
      }).setNegativeButton("NO",new DialogInterface.OnClickListener(){
        override def onClick(interface:DialogInterface,which:Int){
          func_no()
        }
      }).create.show()

  }
  def messageDialog(context:Context,arg:Either[String,Int],func_done:Unit=>Unit=identity[Unit]){
    val builder = new AlertDialog.Builder(context)
    val str = arg match {
      case Left(x) => x
      case Right(x) => context.getResources().getString(x)
    }
    builder.setMessage(str).setPositiveButton("OK",new DialogInterface.OnClickListener(){
        override def onClick(interface:DialogInterface,which:Int){
          func_done()
        }
      }).create.show()
  }

  def generalHtmlDialog(context:Context,html_id:Int){
    val builder= new AlertDialog.Builder(context)
    val view = LayoutInflater.from(context).inflate(R.layout.general_scroll,null)
    val html = context.getResources().getString(html_id)
    view.findViewById(R.id.general_scroll_body).asInstanceOf[TextView].setText(Html.fromHtml(html))
    builder.setView(view)
    builder.setPositiveButton("OK", new DialogInterface.OnClickListener(){
        override def onClick(interface:DialogInterface,which:Int){
        }
      });
    builder.create.show()
  }

  def walkDir(cur:File,depth:Int,func:(File)=>Unit){
    // Checking whether File object is not null is usually not required.
    // However I will check it just for sure.
    if(depth == 0 || cur == null){
      return
    }
    val files = cur.listFiles()
    if(files == null){
      // There seems some directory which File.isDirectory is `true',
      // but File.listFiles returns `null'.
      return
    }
    for( f <- files ){
      if( f != null ){
        func(f)
        if( f.isDirectory ){
          walkDir(f,depth - 1,func)
        }
      }
    }
  }
  def setButtonTextByState(context:Context){
    Globals.setButtonText.foreach( func =>
      func(
      if(Globals.is_playing){
        Right(R.string.now_playing)
      }else if(!Globals.notify_timers.isEmpty){
        Left(Utils.makeTimerText(context))
      }else{
        Left(FudaListHelper.makeReadIndexMessage(context))
      }))
  }
  trait PrefTrait[T] {
    def from(s:String):T
    def >(a:T,b:T):Boolean
  }
  implicit val LongPrefTrait = new PrefTrait[Long] {
    def from(s : String) = s.toLong
    def >(a:Long,b:Long):Boolean = a > b
  }
  implicit val IntPrefTrait = new PrefTrait[Int] {
    def from(s : String) = s.toInt
    def >(a:Int,b:Int):Boolean = a > b
  }
  implicit val DoublePrefTrait = new PrefTrait[Double] {
    def from(s : String) = s.toDouble
    def >(a:Double,b:Double):Boolean = a > b
  }

  def getPrefAs[T:PrefTrait](key:String,defValue:T,maxValue:T):T = {
    if(Globals.prefs.isEmpty){
      return defValue
    }
    val r = try{
      val v = Globals.prefs.get.getString(key,defValue.toString)
      implicitly[PrefTrait[T]].from(v)
    }catch{
      case e:NumberFormatException => defValue
    }
    if( implicitly[PrefTrait[T]].>(r,maxValue)  ){
      maxValue
    }else{
      r
    }
  }

  def deleteCache(context:Context,match_func:String=>Boolean){
    Globals.global_lock.synchronized{
      val files = context.getCacheDir().listFiles()
      if(files != null){
        for(f <- files){
          if(match_func(f.getAbsolutePath())){
            try{
              f.delete()
            }catch{
              case _:Exception => None
            }
          }
        }
      }
    }
  }
  // NOTE: Base64 is only supported on Android 2.2+(API Level 8.)
  //       However, we don't need to catch NoClassDefFoundError since
  //       it is only used when Equalizer which requires API Level 9, is enabled.
  def serializeToString(obj:Any):String = {
    val baos = new ByteArrayOutputStream()
    val oos = new ObjectOutputStream(baos)
    oos.writeObject(obj)
    oos.close()
    return Base64.encodeToString(baos.toByteArray,Base64.DEFAULT)
  }
  def deserializeFromString(str:String):Any = {
    val data = Base64.decode(str,Base64.DEFAULT)
    val ois = new ObjectInputStream(new ByteArrayInputStream(data))
    val o = ois.readObject()
    ois.close()
    return o
  }

  def saveAndSetAudioVolume(context:Context){
    val pref_audio_volume = Globals.prefs.get.getString("audio_volume","")
    if(!TextUtils.isEmpty(pref_audio_volume)){
      val am = context.getSystemService(Context.AUDIO_SERVICE).asInstanceOf[AudioManager]
      if(am != null){
        val max_volume = am.getStreamMaxVolume(AudioManager.STREAM_MUSIC)
        val new_volume = math.min((pref_audio_volume.toFloat*max_volume).toInt,max_volume)
        Globals.audio_volume_bkup = Some(am.getStreamVolume(AudioManager.STREAM_MUSIC))
        am.setStreamVolume(AudioManager.STREAM_MUSIC,new_volume,0)
      }
    }
  }

  def restoreAudioVolume(context:Context){
    Globals.audio_volume_bkup.foreach{ volume =>
        val am = context.getSystemService(Context.AUDIO_SERVICE).asInstanceOf[AudioManager]
        if(am != null){
          am.setStreamVolume(AudioManager.STREAM_MUSIC,volume,0)
        }
    }
    Globals.audio_volume_bkup = None
  }

  def setAudioPlayButton(view:View,context:Context,before_play:Option[KarutaPlayer=>Unit]=None){
    val btn = view.findViewById(R.id.audio_play).asInstanceOf[Button]
    val handler = new Handler()
    btn.setOnClickListener(new View.OnClickListener(){
      override def onClick(v:View){
        Globals.global_lock.synchronized{
          Globals.player match{
            case Some(pl) => {
              if(Globals.is_playing){
                pl.stop()
                btn.setText(context.getResources().getString(R.string.audio_play))
              }else{
                before_play.foreach(_(pl))
                pl.play( _ => {
                  handler.post(new Runnable(){
                    override def run(){
                      btn.setText(context.getResources().getString(R.string.audio_play))
                    }
                  })
                })
                btn.setText(context.getResources().getString(R.string.audio_stop))
              }
            }
            case None =>
              handler.post(new Runnable(){
                override def run(){
                  Utils.messageDialog(context,Right(R.string.player_error_noplay))
                }
              })
          }
        }
      }
    })
  }
  def getPrefsEqualizer():EqualizerSeq = {
    val str = Globals.prefs.get.getString("effect_equalizer","")
    if(TextUtils.isEmpty(str)){
      new EqualizerSeq()
    }else{
      try{
        Utils.deserializeFromString(str).asInstanceOf[EqualizerSeq]
      }catch{
        // Using ProGuard to Serializable class causes 'InvalidClassException: Incompatible class (SUID)'.
        // This problem is already solved by adding @SerialVersionUID to EqualizerSeq.
        // However upgrading wasuramoti from old version still occures this exception.
        // NOTE: it seems that as for scala, it does not need to set proguardOption =
        //       -keepclassmembers class karuta.hpnpwd.wasuramoti.EqualizerSeq{
        //          static final long serialVersionUID;
        //          ... }
        //       However, if something wrong occures for serialization, try adding these options to build.scala.
        //       See ProGuard manual for further information.
        case e:InvalidClassException => new EqualizerSeq()
        case e:ClassCastException => new EqualizerSeq()
      }
    }
  }
}

